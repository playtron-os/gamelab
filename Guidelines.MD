# Coding conventions and guidelines

[go back to README](./README.md)

This document presents current conventions and guidelines to be followed when contributing to the project, please read them thoroughly before writing any code.

## Golden rules

1. Don't ignore the linter or TypeScript warnings/errors unless you have a specific reason that's been approved during code reviews.
2. Leave TODO comments for any pending work related to what you're working on that should eventually be addressed but is not within your current scope or the highest priority.
3. Strive for clean and readable code. Refactoring for the sake of code quality is encouraged.

## Naming conventions

We should pay attention to the project naming conventions:

- **File name**: dash-case
- **Folder name**: dash-case
- **Classname**: dash-case
- **Variable name**: camelCase
  - For playserve responses that comes in snake_case we can use the `camelCaseKeys` util from `@/utils/object` on the response to convert all nested properties to camelCase when handling the response
  - For now we still have a few snake_case variable occurences since we weren't following the suggestion above from the start, they should eventually get refactored. 
- **Function name**: camelCase
- **Interface/Type**: PascalCase
- **Constant**: CAPITAL_SNAKE_CASE

## React components

1. **File Organization**: Each component should reside in its own file. For composite components, organize related subcomponents into a ./components subfolder.

    **Example**:
    - Main component: src/components/MyComponent/MyComponent.tsx
    - Subcomponent: src/components/MyComponent/components/SubComponent.tsx

2. **State Management**: Prefer stateless (a.k.a "dumber") functional components for subcomponents. Keep state either in the parent component or a state manager like Redux or React Context.

### Creating new components

We can use the `yarn generate` script to generate a new component that follows the project guidelines including test,index and style files, or you can create it by yourself. Keep in mind the naming conventions above!

## Tests

When adding/modifying logic, please make sure to write/maintain tests for the logic you're working with. Before putting up a PR run the coverage command (`pnpm test:coverage`) and make sure your code has good coverage.

## Use typescript!

This project has typescript setup and have to use it!

Here are some guidelines you should follow:

1. **Always avoid using any**, either implicitly or explicitly.
2. **Whenever possible, define a type or interface**, they should go inside the `src/types` folder.
3. Pay attention to linter warnings/errors

## Playserve integration

Most if not all functionality comes from playserve, our local websocket server that can be used by any UI app. 

When integrating a new playserve endpoint make sure you:

1. Add the new message type to the [MessageType](src/types/playserve/message.ts) enum.
2. Map MessageType to appropriate request and response types (see [Types](#types))
3. Always use [getMessage](src/types/playserve/message.ts) util when creating the request message to ensure we have consistent and correct requests.
4. To use playserve you should use the `usePlayserve` hook.

### Types

Always define types for playserve request/response when using it, if not done already.

For request messages extend the `MessageRequestMapping` type. It's used to automatically enforce types based on MessageType

Similarly for response types use the `MessageResponseMapping`.

Messages that aren't mapped have unknown body type.

### usePlayserve

The usePlayserve hook provide you ways to interact with playserve, we can either work with it using its returned values or by using the props it supports.

Here are some examples with the most common tools used from the hook.

#### Returned values

##### sendMessage
`sendMessage` is function that you can use to send a message generated by the `getMessage` util.

```
const { sendMessage } = usePlayserve();
...
const messageToSend = getMessage(MessageType.AppGetOwned, {
  user_id: userId,
})
sendMessage(messageToSend)().then((response) => {
  // response type is automatically mapped based on MessageType
  handleOwnedAppsResponse(response)
})
...
```

#### Supported props

##### Message event listeners
To add playserve message event listeners it is recommended that you pass a `onMessage` prop to the hook like this:
```
  usePlayserve({
    onMessage: (event) => {
      if(event.message_type === MessageType.AppGetOwnedUpdate && event.status === 200) {
        handleOwnedAppsUpdateResponse(event);
      }
    }
  });
```

Note that the type any here is ok since we can be listening to multiple different responses, also note that once we know the type we can cast it as we're doing when passing event to the handler function.

Check out the [usePlayserve](src/hooks/use-playserve.ts) and search for it in the codebase for more information on what's possible with it.

## Code Reviews

Code reviews are an essential part of our development process. They provide multiple perspectives on a problem, spread knowledge across the team, and ensure a consistent level of quality in our codebase. Below are some guidelines to follow during the code review process.

### For Contributors
1. Preparation: Before submitting your code for review, make sure it adheres to the guidelines and conventions outlined in this document. Run all tests and ensure your code is up to date with the latest version of main.
2. Description: Provide a comprehensive description in your pull request to explain what changes you're introducing, videos/screenshots are really nice to have when dealing with UI work.
3. Small Changes: Keep your pull requests small and focused. If a large change is unavoidable, break it down into smaller PRs, this will ease the process for reviewers making it quicker and allowing them to understand and review better what you're doing.
4. Tag Reviewers: Tag team members who have expertise in the area you've modified. If you're not sure who to tag, you can tag a team lead or ask for recommendations.
5. Respond Promptly: Address review comments as soon as possible. If you disagree with a comment, provide a clear argument for your point of view.

### For Reviewers
1. Timeliness: Try to conduct your reviews in a timely manner. Aim to review within 48 hours of a pull request being submitted if possible.
2. Focus on What Matters: While code style is important, prioritize feedback on the architecture, design, and functionality of the code above all else.
3. Be Constructive: Provide constructive feedback and suggest alternatives if you disagree with an approach. Use phrases like "consider doing..." instead of "do not do...".
4. Ask for Clarifications: If something is unclear, don't hesitate to ask for clarifications or additional information.
5. Approve with Caution: Only approve a pull request if you are confident that the changes are correct, necessary, and in accordance with our guidelines.
6. Check for Tests: Ensure that the code includes appropriate tests and that all tests are passing.
7. Merge Responsibility: The PR owner is responsible for merging the code once approved.

## State management 

When dealing with state that is used across multiple components in the app (not just subcomponents of a component), it's usually a good a idea to move it to a centralized state manager such as redux or react context (both are ready to use in this project).

### Redux

Redux is good for complex state logic where you can have multiple reducers or middlewares to manage async actions. This project has redux toolkit setup, which simplifies a lot of the boilerplate involved in setting up a Redux app, offering utilities like auto-slicing and createAsyncThunk for easier async operations.

New modules should be added to `src/redux/modules` and should include a test for it as well, check out the existing modules for examples. 

[More Info](https://redux-toolkit.js.org).

### React context
React Context is usually simpler (a bit less boilerplate) even when compared to the simplistic redux toolkit, it also has the advantage of being able to store non serializable values such as function references, so if you need a function reference in your global state, you should probably go for react context.

For this app specifically, since we're not using any thunks to deal with api data (all api interaction is made through playserve), it seems like React Context could handle most if not all of our needs.

New contexts should be added to `src/context` and should include a test file as well, check out the existing contexts for examples.

[More info](https://react.dev/learn/passing-data-deeply-with-context)
